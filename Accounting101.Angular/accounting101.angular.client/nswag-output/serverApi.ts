//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AllClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @return OK
     */
    refresh(body: RefreshRequest): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<AccessTokenResponse>;
                }
            } else
                throw new Error(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId
     * @param code
     * @param changedEmail (optional)
     * @return OK
     */
    confirmEmail(userId: string, code: string, changedEmail: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/confirmEmail?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail === null)
            throw new Error("The parameter 'changedEmail' cannot be null.");
        else if (changedEmail !== undefined)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<void>;
                }
            } else
                throw new Error(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resendConfirmationEmail(body: ResendConfirmationEmailRequest): Observable<void> {
        let url_ = this.baseUrl + "/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendConfirmationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendConfirmationEmail(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<void>;
                }
            } else
                throw new Error(response_) as any as Observable<void>;
        }));
    }

    protected processResendConfirmationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    forgotPassword(body: ForgotPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<void>;
                }
            } else
                throw new Error(response_) as any as Observable<void>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resetPassword(body: ResetPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<void>;
                }
            } else
                throw new Error(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    accountsGet(dbId: string, clientId: string): Observable<AccountWithInfo[]> {
        let url_ = this.baseUrl + "/Accounts/{dbId}/{clientId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountsGet(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<AccountWithInfo[]>;
                }
            } else
                throw new Error(response_) as any as Observable<AccountWithInfo[]>;
        }));
    }

    protected processAccountsGet(response: HttpResponseBase): Observable<AccountWithInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountWithInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dbId
     * @param clientId
     * @param body (optional)
     * @return OK
     */
    accountsPost(dbId: string, clientId: string, body: AccountWithInfo | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Accounts/{dbId}/{clientId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountsPost(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<string>;
                }
            } else
                throw new Error(response_) as any as Observable<string>;
        }));
    }

    protected processAccountsPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    address(dbId: string): Observable<string> {
        let url_ = this.baseUrl + "/Address/{dbId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddress(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<string>;
                }
            } else
                throw new Error(response_) as any as Observable<string>;
        }));
    }

    protected processAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    businessGet(dbId: string): Observable<Business> {
        let url_ = this.baseUrl + "/Business/{dbId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBusinessGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBusinessGet(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<Business>;
                }
            } else
                throw new Error(response_) as any as Observable<Business>;
        }));
    }

    protected processBusinessGet(response: HttpResponseBase): Observable<Business> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Business.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    businessPost(dbId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/Business/{dbId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBusinessPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBusinessPost(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<boolean>;
                }
            } else
                throw new Error(response_) as any as Observable<boolean>;
        }));
    }

    protected processBusinessPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    businessDelete(dbId: string): Observable<void> {
        let url_ = this.baseUrl + "/Business/{dbId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBusinessDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBusinessDelete(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<void>;
                }
            } else
                throw new Error(response_) as any as Observable<void>;
        }));
    }

    protected processBusinessDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    clientsGet(dbId: string): Observable<ClientWithInfo[]> {
        let url_ = this.baseUrl + "/Clients/{dbId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientsGet(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<ClientWithInfo[]>;
                }
            } else
                throw new Error(response_) as any as Observable<ClientWithInfo[]>;
        }));
    }

    protected processClientsGet(response: HttpResponseBase): Observable<ClientWithInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientWithInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dbId
     * @param body (optional)
     * @return OK
     */
    clientsPost(dbId: string, body: Client | undefined): Observable<Client> {
        let url_ = this.baseUrl + "/Clients/{dbId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientsPost(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<Client>;
                }
            } else
                throw new Error(response_) as any as Observable<Client>;
        }));
    }

    protected processClientsPost(response: HttpResponseBase): Observable<Client> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Client.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    clientsDelete(dbId: string, clientId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/Clients/{dbId}/{clientId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientsDelete(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<boolean>;
                }
            } else
                throw new Error(response_) as any as Observable<boolean>;
        }));
    }

    protected processClientsDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dbId
     * @param body (optional)
     * @return OK
     */
    personName(dbId: string, body: PersonName | undefined): Observable<PersonName> {
        let url_ = this.baseUrl + "/person-name/{dbId}";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonName(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<PersonName>;
                }
            } else
                throw new Error(response_) as any as Observable<PersonName>;
        }));
    }

    protected processPersonName(response: HttpResponseBase): Observable<PersonName> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonName.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ManageClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @return OK
     */
    multiFactor(body: TwoFactorRequest): Observable<TwoFactorResponse> {
        let url_ = this.baseUrl + "/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this. processMultiFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this. processMultiFactor(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<TwoFactorResponse>;
                }
            } else
                throw new Error(response_) as any as Observable<TwoFactorResponse>;
        }));
    }

    protected  processMultiFactor(response: HttpResponseBase): Observable<TwoFactorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    infoGet(): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInfoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInfoGet(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<InfoResponse>;
                }
            } else
                throw new Error(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processInfoGet(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    infoPost(body: InfoRequest): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInfoPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInfoPost(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<InfoResponse>;
                }
            } else
                throw new Error(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processInfoPost(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AccountsClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @return OK
     */
    exist(dbId: string, clientId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/Accounts/{dbId}/{clientId}/exist";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExist(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<boolean>;
                }
            } else
                throw new Error(response_) as any as Observable<boolean>;
        }));
    }

    protected processExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    layoutGet(dbId: string, clientId: string): Observable<RootGroup> {
        let url_ = this.baseUrl + "/Accounts/{dbId}/{clientId}/layout";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLayoutGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLayoutGet(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<RootGroup>;
                }
            } else
                throw new Error(response_) as any as Observable<RootGroup>;
        }));
    }

    protected processLayoutGet(response: HttpResponseBase): Observable<RootGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RootGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dbId
     * @param clientId
     * @param body (optional)
     * @return OK
     */
    layoutPost(dbId: string, clientId: string, body: RootGroup | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/Accounts/{dbId}/{clientId}/layout";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLayoutPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLayoutPost(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<boolean>;
                }
            } else
                throw new Error(response_) as any as Observable<boolean>;
        }));
    }

    protected processLayoutPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    transactionsGet(dbId: string, accountId: string): Observable<Transaction[]> {
        let url_ = this.baseUrl + "/Accounts/{dbId}/{accountId}/transactions";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransactionsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransactionsGet(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<Transaction[]>;
                }
            } else
                throw new Error(response_) as any as Observable<Transaction[]>;
        }));
    }

    protected processTransactionsGet(response: HttpResponseBase): Observable<Transaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Transaction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    transactionsPost(dbId: string, clientId: string): Observable<string> {
        let url_ = this.baseUrl + "/Accounts/{dbId}/{clientId}/transactions";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransactionsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransactionsPost(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<string>;
                }
            } else
                throw new Error(response_) as any as Observable<string>;
        }));
    }

    protected processTransactionsPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AddressClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @return OK
     */
    states(): Observable<string[]> {
        let url_ = this.baseUrl + "/Address/states";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStates(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<string[]>;
                }
            } else
                throw new Error(response_) as any as Observable<string[]>;
        }));
    }

    protected processStates(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    countries(): Observable<string[]> {
        let url_ = this.baseUrl + "/Address/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<string[]>;
                }
            } else
                throw new Error(response_) as any as Observable<string[]>;
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthorizationClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @param body (optional)
     * @return OK
     */
    register(body: RegisterModel | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/Authorization/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<ApplicationUser>;
                }
            } else
                throw new Error(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    login(body: LoginModel | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/Authorization/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<ApplicationUser>;
                }
            } else
                throw new Error(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    isAuthenticated(): Observable<void> {
        let url_ = this.baseUrl + "/Authorization/is-authenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsAuthenticated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAuthenticated(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<void>;
                }
            } else
                throw new Error(response_) as any as Observable<void>;
        }));
    }

    protected processIsAuthenticated(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/Authorization/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<void>;
                }
            } else
                throw new Error(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @return OK
     */
    exists(dbId: string): Observable<Business> {
        let url_ = this.baseUrl + "/Business/{dbId}/exists";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<Business>;
                }
            } else
                throw new Error(response_) as any as Observable<Business>;
        }));
    }

    protected processExists(response: HttpResponseBase): Observable<Business> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Business.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ClientsClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @return OK
     */
    exist(dbId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/Clients/{dbId}/exist";
        if (dbId === undefined || dbId === null)
            throw new Error("The parameter 'dbId' must be defined.");
        url_ = url_.replace("{dbId}", encodeURIComponent("" + dbId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExist(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<boolean>;
                }
            } else
                throw new Error(response_) as any as Observable<boolean>;
        }));
    }

    protected processExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CoaClient {
    private http: HttpClient;
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://";
    }

    /**
     * @return OK
     */
    availableNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/Coa/available-names";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableNames(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<string[]>;
                }
            } else
                throw new Error(response_) as any as Observable<string[]>;
        }));
    }

    protected processAvailableNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    description(name: string): Observable<ChartItem> {
        let url_ = this.baseUrl + "/Coa/description/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescription(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<ChartItem>;
                }
            } else
                throw new Error(response_) as any as Observable<ChartItem>;
        }));
    }

    protected processDescription(response: HttpResponseBase): Observable<ChartItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    create(body: CreateCoARequest | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/Coa/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    throw new Error(JSON.stringify(e)) as any as Observable<boolean>;
                }
            } else
                throw new Error(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AccessTokenResponse implements IAccessTokenResponse {
    readonly tokenType?: string | undefined;
    accessToken!: string | undefined;
    expiresIn!: number;
    refreshToken!: string | undefined;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string | undefined;
    accessToken: string | undefined;
    expiresIn: number;
    refreshToken: string | undefined;
}

export class AccountGroup implements IAccountGroup {
    id?: string;
    name?: string | undefined;
    items?: AccountGroupListItem[] | undefined;

    constructor(data?: IAccountGroup) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccountGroupListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountGroup {
        data = typeof data === 'object' ? data : {};
        let result = new AccountGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAccountGroup {
    id?: string;
    name?: string | undefined;
    items?: AccountGroupListItem[] | undefined;
}

export class AccountGroupListItem implements IAccountGroupListItem {
    type?: AccountGroupListItemType;
    accountId?: string | undefined;
    accountGroup?: AccountGroup;

    constructor(data?: IAccountGroupListItem) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.accountId = _data["accountId"];
            this.accountGroup = _data["accountGroup"] ? AccountGroup.fromJS(_data["accountGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountGroupListItem {
        data = typeof data === 'object' ? data : {};
        let result = new AccountGroupListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["accountId"] = this.accountId;
        data["accountGroup"] = this.accountGroup ? this.accountGroup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountGroupListItem {
    type?: AccountGroupListItemType;
    accountId?: string | undefined;
    accountGroup?: AccountGroup;
}

export enum AccountGroupListItemType {
    Group = "Group",
    Account = "Account",
}

export class AccountInfo implements IAccountInfo {
    id?: string;
    coAId?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAccountInfo) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coAId = _data["coAId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AccountInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AccountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coAId"] = this.coAId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAccountInfo {
    id?: string;
    coAId?: string | undefined;
    name?: string | undefined;
}

export class AccountWithInfo implements IAccountWithInfo {
    id?: string;
    type?: BaseAccountTypes;
    clientId?: string | undefined;
    infoId?: string | undefined;
    startBalance?: number;
    readonly isDebitAccount?: boolean;
    created?: Date;
    info?: AccountInfo;

    constructor(data?: IAccountWithInfo) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.clientId = _data["clientId"];
            this.infoId = _data["infoId"];
            this.startBalance = _data["startBalance"];
            (<any>this).isDebitAccount = _data["isDebitAccount"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.info = _data["info"] ? AccountInfo.fromJS(_data["info"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountWithInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AccountWithInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["clientId"] = this.clientId;
        data["infoId"] = this.infoId;
        data["startBalance"] = this.startBalance;
        data["isDebitAccount"] = this.isDebitAccount;
        data["created"] = this.created ? formatDate(this.created) : <any>undefined;
        data["info"] = this.info ? this.info.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountWithInfo {
    id?: string;
    type?: BaseAccountTypes;
    clientId?: string | undefined;
    infoId?: string | undefined;
    startBalance?: number;
    isDebitAccount?: boolean;
    created?: Date;
    info?: AccountInfo;
}

export class ApplicationUser implements IApplicationUser {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    roles?: string[] | undefined;
    claims?: StringIdentityUserClaim[] | undefined;
    logins?: StringIdentityUserLogin[] | undefined;
    tokens?: StringIdentityUserToken[] | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(StringIdentityUserClaim.fromJS(item));
            }
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(StringIdentityUserLogin.fromJS(item));
            }
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(StringIdentityUserToken.fromJS(item));
            }
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IApplicationUser {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    roles?: string[] | undefined;
    claims?: StringIdentityUserClaim[] | undefined;
    logins?: StringIdentityUserLogin[] | undefined;
    tokens?: StringIdentityUserToken[] | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export enum AvailableCoAs {
    SmallBusiness = "SmallBusiness",
}

export enum BaseAccountTypes {
    Asset = "Asset",
    Expense = "Expense",
    Liability = "Liability",
    Equity = "Equity",
    Revenue = "Revenue",
    Earnings = "Earnings",
}

export class Business implements IBusiness {
    id?: ObjectId;
    name?: string | undefined;
    address?: IAddress;

    constructor(data?: IBusiness) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] ? ObjectId.fromJS(_data["id"]) : <any>undefined;
            this.name = _data["name"];
            this.address = _data["address"] ? IAddress.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Business {
        data = typeof data === 'object' ? data : {};
        let result = new Business();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id ? this.id.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBusiness {
    id?: ObjectId;
    name?: string | undefined;
    address?: IAddress;
}

export class ChartItem implements IChartItem {
    name?: string | undefined;
    description?: string | undefined;
    readonly readableType?: string | undefined;
    type?: AvailableCoAs;

    constructor(data?: IChartItem) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            (<any>this).readableType = _data["readableType"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ChartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["readableType"] = this.readableType;
        data["type"] = this.type;
        return data;
    }
}

export interface IChartItem {
    name?: string | undefined;
    description?: string | undefined;
    readableType?: string | undefined;
    type?: AvailableCoAs;
}

export class Client implements IClient {
    id?: string;
    businessName?: string | undefined;
    personNameId?: string | undefined;
    addressId?: string | undefined;
    checkPointId?: string | undefined;

    constructor(data?: IClient) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessName = _data["businessName"];
            this.personNameId = _data["personNameId"];
            this.addressId = _data["addressId"];
            this.checkPointId = _data["checkPointId"];
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessName"] = this.businessName;
        data["personNameId"] = this.personNameId;
        data["addressId"] = this.addressId;
        data["checkPointId"] = this.checkPointId;
        return data;
    }
}

export interface IClient {
    id?: string;
    businessName?: string | undefined;
    personNameId?: string | undefined;
    addressId?: string | undefined;
    checkPointId?: string | undefined;
}

export class ClientWithInfo implements IClientWithInfo {
    id?: string;
    businessName?: string | undefined;
    personNameId?: string | undefined;
    addressId?: string | undefined;
    checkPointId?: string | undefined;
    contactName?: PersonName;
    address?: IAddress;
    usAddress?: UsAddress;
    foreignAddress?: ForeignAddress;

    constructor(data?: IClientWithInfo) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessName = _data["businessName"];
            this.personNameId = _data["personNameId"];
            this.addressId = _data["addressId"];
            this.checkPointId = _data["checkPointId"];
            this.contactName = _data["contactName"] ? PersonName.fromJS(_data["contactName"]) : <any>undefined;
            this.address = _data["address"] ? IAddress.fromJS(_data["address"]) : <any>undefined;
            this.usAddress = _data["usAddress"] ? UsAddress.fromJS(_data["usAddress"]) : <any>undefined;
            this.foreignAddress = _data["foreignAddress"] ? ForeignAddress.fromJS(_data["foreignAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientWithInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWithInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessName"] = this.businessName;
        data["personNameId"] = this.personNameId;
        data["addressId"] = this.addressId;
        data["checkPointId"] = this.checkPointId;
        data["contactName"] = this.contactName ? this.contactName.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["usAddress"] = this.usAddress ? this.usAddress.toJSON() : <any>undefined;
        data["foreignAddress"] = this.foreignAddress ? this.foreignAddress.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientWithInfo {
    id?: string;
    businessName?: string | undefined;
    personNameId?: string | undefined;
    addressId?: string | undefined;
    checkPointId?: string | undefined;
    contactName?: PersonName;
    address?: IAddress;
    usAddress?: UsAddress;
    foreignAddress?: ForeignAddress;
}

export class CreateCoARequest implements ICreateCoARequest {
    name?: string | undefined;
    dbName?: string | undefined;
    clientId?: string;

    constructor(data?: ICreateCoARequest) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dbName = _data["dbName"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): CreateCoARequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCoARequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dbName"] = this.dbName;
        data["clientId"] = this.clientId;
        return data;
    }
}

export interface ICreateCoARequest {
    name?: string | undefined;
    dbName?: string | undefined;
    clientId?: string;
}

export class ForeignAddress implements IForeignAddress {
    id?: string;
    readonly usedByIds?: string[] | undefined;
    country?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    province?: string | undefined;
    postalCode?: string | undefined;

    constructor(data?: IForeignAddress) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["usedByIds"])) {
                (<any>this).usedByIds = [] as any;
                for (let item of _data["usedByIds"])
                    (<any>this).usedByIds!.push(item);
            }
            this.country = _data["country"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
        }
    }

    static fromJS(data: any): ForeignAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.usedByIds)) {
            data["usedByIds"] = [];
            for (let item of this.usedByIds)
                data["usedByIds"].push(item);
        }
        data["country"] = this.country;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        return data;
    }
}

export interface IForeignAddress {
    id?: string;
    usedByIds?: string[] | undefined;
    country?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    province?: string | undefined;
    postalCode?: string | undefined;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string | undefined;
}

export class HttpValidationProblemDetails implements IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (const property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (const property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class IAddress implements IIAddress {
    id?: string;
    readonly usedByIds?: string[] | undefined;
    country?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;

    constructor(data?: IIAddress) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["usedByIds"])) {
                (<any>this).usedByIds = [] as any;
                for (let item of _data["usedByIds"])
                    (<any>this).usedByIds!.push(item);
            }
            this.country = _data["country"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
        }
    }

    static fromJS(data: any): IAddress {
        data = typeof data === 'object' ? data : {};
        let result = new IAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.usedByIds)) {
            data["usedByIds"] = [];
            for (let item of this.usedByIds)
                data["usedByIds"].push(item);
        }
        data["country"] = this.country;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        return data;
    }
}

export interface IIAddress {
    id?: string;
    usedByIds?: string[] | undefined;
    country?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class InfoResponse implements IInfoResponse {
    email!: string | undefined;
    isEmailConfirmed!: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email: string | undefined;
    isEmailConfirmed: boolean;
}

export class LoginModel implements ILoginModel {
    email?: string | undefined;
    password?: string | undefined;
    multiFactorAuthenticationCode?: string | undefined;
    multiFactorAuthenticationResetCode?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.multiFactorAuthenticationCode = _data["multiFactorAuthenticationCode"];
            this.multiFactorAuthenticationResetCode = _data["multiFactorAuthenticationResetCode"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["multiFactorAuthenticationCode"] = this.multiFactorAuthenticationCode;
        data["multiFactorAuthenticationResetCode"] = this.multiFactorAuthenticationResetCode;
        return data;
    }
}

export interface ILoginModel {
    email?: string | undefined;
    password?: string | undefined;
    multiFactorAuthenticationCode?: string | undefined;
    multiFactorAuthenticationResetCode?: string | undefined;
}

export class ObjectId implements IObjectId {
    readonly timestamp?: number;
    readonly creationTime?: Date;

    constructor(data?: IObjectId) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).timestamp = _data["timestamp"];
            (<any>this).creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectId {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IObjectId {
    timestamp?: number;
    creationTime?: Date;
}

export class PersonName implements IPersonName {
    id?: string;
    clientId?: string | undefined;
    readonly usedByIds?: string[] | undefined;
    prefix?: string | undefined;
    first?: string | undefined;
    middle?: string | undefined;
    last?: string | undefined;
    suffix?: string | undefined;

    constructor(data?: IPersonName) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            if (Array.isArray(_data["usedByIds"])) {
                (<any>this).usedByIds = [] as any;
                for (let item of _data["usedByIds"])
                    (<any>this).usedByIds!.push(item);
            }
            this.prefix = _data["prefix"];
            this.first = _data["first"];
            this.middle = _data["middle"];
            this.last = _data["last"];
            this.suffix = _data["suffix"];
        }
    }

    static fromJS(data: any): PersonName {
        data = typeof data === 'object' ? data : {};
        let result = new PersonName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        if (Array.isArray(this.usedByIds)) {
            data["usedByIds"] = [];
            for (let item of this.usedByIds)
                data["usedByIds"].push(item);
        }
        data["prefix"] = this.prefix;
        data["first"] = this.first;
        data["middle"] = this.middle;
        data["last"] = this.last;
        data["suffix"] = this.suffix;
        return data;
    }
}

export interface IPersonName {
    id?: string;
    clientId?: string | undefined;
    usedByIds?: string[] | undefined;
    prefix?: string | undefined;
    first?: string | undefined;
    middle?: string | undefined;
    last?: string | undefined;
    suffix?: string | undefined;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken: string | undefined;
}

export class RegisterModel implements IRegisterModel {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    role?: string | undefined;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["role"] = this.role;
        return data;
    }
}

export interface IRegisterModel {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    role?: string | undefined;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email!: string | undefined;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email: string | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string | undefined;
    resetCode!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string | undefined;
    resetCode: string | undefined;
    newPassword: string | undefined;
}

export class RootGroup implements IRootGroup {
    id?: string;
    clientId?: string | undefined;
    assets?: AccountGroup;
    liabilities?: AccountGroup;
    equity?: AccountGroup;
    revenue?: AccountGroup;
    expenses?: AccountGroup;
    earnings?: AccountGroup;

    constructor(data?: IRootGroup) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.assets = _data["assets"] ? AccountGroup.fromJS(_data["assets"]) : <any>undefined;
            this.liabilities = _data["liabilities"] ? AccountGroup.fromJS(_data["liabilities"]) : <any>undefined;
            this.equity = _data["equity"] ? AccountGroup.fromJS(_data["equity"]) : <any>undefined;
            this.revenue = _data["revenue"] ? AccountGroup.fromJS(_data["revenue"]) : <any>undefined;
            this.expenses = _data["expenses"] ? AccountGroup.fromJS(_data["expenses"]) : <any>undefined;
            this.earnings = _data["earnings"] ? AccountGroup.fromJS(_data["earnings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RootGroup {
        data = typeof data === 'object' ? data : {};
        let result = new RootGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["assets"] = this.assets ? this.assets.toJSON() : <any>undefined;
        data["liabilities"] = this.liabilities ? this.liabilities.toJSON() : <any>undefined;
        data["equity"] = this.equity ? this.equity.toJSON() : <any>undefined;
        data["revenue"] = this.revenue ? this.revenue.toJSON() : <any>undefined;
        data["expenses"] = this.expenses ? this.expenses.toJSON() : <any>undefined;
        data["earnings"] = this.earnings ? this.earnings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRootGroup {
    id?: string;
    clientId?: string | undefined;
    assets?: AccountGroup;
    liabilities?: AccountGroup;
    equity?: AccountGroup;
    revenue?: AccountGroup;
    expenses?: AccountGroup;
    earnings?: AccountGroup;
}

export class StringIdentityUserClaim implements IStringIdentityUserClaim {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IStringIdentityUserClaim) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): StringIdentityUserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdentityUserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IStringIdentityUserClaim {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class StringIdentityUserLogin implements IStringIdentityUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IStringIdentityUserLogin) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.providerDisplayName = _data["providerDisplayName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): StringIdentityUserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdentityUserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["providerDisplayName"] = this.providerDisplayName;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IStringIdentityUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;
}

export class StringIdentityUserToken implements IStringIdentityUserToken {
    userId?: string | undefined;
    loginProvider?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IStringIdentityUserToken) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringIdentityUserToken {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdentityUserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IStringIdentityUserToken {
    userId?: string | undefined;
    loginProvider?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export class Transaction implements ITransaction {
    id?: string;
    readonly creditedAccountId?: string | undefined;
    readonly debitedAccountId?: string | undefined;
    readonly amount?: number;
    readonly when?: Date;

    constructor(data?: ITransaction) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).creditedAccountId = _data["creditedAccountId"];
            (<any>this).debitedAccountId = _data["debitedAccountId"];
            (<any>this).amount = _data["amount"];
            (<any>this).when = _data["when"] ? new Date(_data["when"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creditedAccountId"] = this.creditedAccountId;
        data["debitedAccountId"] = this.debitedAccountId;
        data["amount"] = this.amount;
        data["when"] = this.when ? formatDate(this.when) : <any>undefined;
        return data;
    }
}

export interface ITransaction {
    id?: string;
    creditedAccountId?: string | undefined;
    debitedAccountId?: string | undefined;
    amount?: number;
    when?: Date;
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey!: string | undefined;
    recoveryCodesLeft!: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled!: boolean;
    isMachineRemembered!: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey: string | undefined;
    recoveryCodesLeft: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled: boolean;
    isMachineRemembered: boolean;
}

export class UsAddress implements IUsAddress {
    id?: string;
    readonly usedByIds?: string[] | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zip?: string | undefined;

    constructor(data?: IUsAddress) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["usedByIds"])) {
                (<any>this).usedByIds = [] as any;
                for (let item of _data["usedByIds"])
                    (<any>this).usedByIds!.push(item);
            }
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): UsAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UsAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.usedByIds)) {
            data["usedByIds"] = [];
            for (let item of this.usedByIds)
                data["usedByIds"].push(item);
        }
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zip"] = this.zip;
        return data;
    }
}

export interface IUsAddress {
    id?: string;
    usedByIds?: string[] | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zip?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' +
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        throw new Error(result);
    else
        throw new Error(JSON.stringify(new ApiException(message, status, response, headers, null)));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
